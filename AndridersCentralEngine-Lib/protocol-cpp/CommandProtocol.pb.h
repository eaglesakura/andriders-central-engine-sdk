// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CommandProtocol.proto

#ifndef PROTOBUF_CommandProtocol_2eproto__INCLUDED
#define PROTOBUF_CommandProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "AcesConstants.pb.h"
#include "GeoProtocol.pb.h"
// @@protoc_insertion_point(includes)

namespace eaglesakura_ace {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CommandProtocol_2eproto();
void protobuf_AssignDesc_CommandProtocol_2eproto();
void protobuf_ShutdownFile_CommandProtocol_2eproto();

class CameraShotPayload;
class TweetRequestPayload;
class TriggerPayload;
class CommandPayload;

enum CommandType {
  ExtensionTrigger = 1,
  AcesControl = 2
};
bool CommandType_IsValid(int value);
const CommandType CommandType_MIN = ExtensionTrigger;
const CommandType CommandType_MAX = AcesControl;
const int CommandType_ARRAYSIZE = CommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommandType_descriptor();
inline const ::std::string& CommandType_Name(CommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommandType_descriptor(), value);
}
inline bool CommandType_Parse(
    const ::std::string& name, CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommandType>(
    CommandType_descriptor(), name, value);
}
enum TriggerType {
  Promiximity = 1,
  Geo = 2,
  Activity = 3
};
bool TriggerType_IsValid(int value);
const TriggerType TriggerType_MIN = Promiximity;
const TriggerType TriggerType_MAX = Activity;
const int TriggerType_ARRAYSIZE = TriggerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TriggerType_descriptor();
inline const ::std::string& TriggerType_Name(TriggerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TriggerType_descriptor(), value);
}
inline bool TriggerType_Parse(
    const ::std::string& name, TriggerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TriggerType>(
    TriggerType_descriptor(), name, value);
}
enum AcesControllCommand {
  TweetRequest = 2
};
bool AcesControllCommand_IsValid(int value);
const AcesControllCommand AcesControllCommand_MIN = TweetRequest;
const AcesControllCommand AcesControllCommand_MAX = TweetRequest;
const int AcesControllCommand_ARRAYSIZE = AcesControllCommand_MAX + 1;

const ::google::protobuf::EnumDescriptor* AcesControllCommand_descriptor();
inline const ::std::string& AcesControllCommand_Name(AcesControllCommand value) {
  return ::google::protobuf::internal::NameOfEnum(
    AcesControllCommand_descriptor(), value);
}
inline bool AcesControllCommand_Parse(
    const ::std::string& name, AcesControllCommand* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AcesControllCommand>(
    AcesControllCommand_descriptor(), name, value);
}
// ===================================================================

class CameraShotPayload : public ::google::protobuf::Message {
 public:
  CameraShotPayload();
  virtual ~CameraShotPayload();

  CameraShotPayload(const CameraShotPayload& from);

  inline CameraShotPayload& operator=(const CameraShotPayload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraShotPayload& default_instance();

  void Swap(CameraShotPayload* other);

  // implements Message ----------------------------------------------

  CameraShotPayload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraShotPayload& from);
  void MergeFrom(const CameraShotPayload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string imageUri = 1;
  inline bool has_imageuri() const;
  inline void clear_imageuri();
  static const int kImageUriFieldNumber = 1;
  inline const ::std::string& imageuri() const;
  inline void set_imageuri(const ::std::string& value);
  inline void set_imageuri(const char* value);
  inline void set_imageuri(const char* value, size_t size);
  inline ::std::string* mutable_imageuri();
  inline ::std::string* release_imageuri();
  inline void set_allocated_imageuri(::std::string* imageuri);

  // required int32 imageWidth = 2;
  inline bool has_imagewidth() const;
  inline void clear_imagewidth();
  static const int kImageWidthFieldNumber = 2;
  inline ::google::protobuf::int32 imagewidth() const;
  inline void set_imagewidth(::google::protobuf::int32 value);

  // required int32 imageHeight = 3;
  inline bool has_imageheight() const;
  inline void clear_imageheight();
  static const int kImageHeightFieldNumber = 3;
  inline ::google::protobuf::int32 imageheight() const;
  inline void set_imageheight(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:eaglesakura_ace.CameraShotPayload)
 private:
  inline void set_has_imageuri();
  inline void clear_has_imageuri();
  inline void set_has_imagewidth();
  inline void clear_has_imagewidth();
  inline void set_has_imageheight();
  inline void clear_has_imageheight();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* imageuri_;
  ::google::protobuf::int32 imagewidth_;
  ::google::protobuf::int32 imageheight_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CommandProtocol_2eproto();
  friend void protobuf_AssignDesc_CommandProtocol_2eproto();
  friend void protobuf_ShutdownFile_CommandProtocol_2eproto();

  void InitAsDefaultInstance();
  static CameraShotPayload* default_instance_;
};
// -------------------------------------------------------------------

class TweetRequestPayload : public ::google::protobuf::Message {
 public:
  TweetRequestPayload();
  virtual ~TweetRequestPayload();

  TweetRequestPayload(const TweetRequestPayload& from);

  inline TweetRequestPayload& operator=(const TweetRequestPayload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TweetRequestPayload& default_instance();

  void Swap(TweetRequestPayload* other);

  // implements Message ----------------------------------------------

  TweetRequestPayload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TweetRequestPayload& from);
  void MergeFrom(const TweetRequestPayload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string tweetMessage = 1;
  inline bool has_tweetmessage() const;
  inline void clear_tweetmessage();
  static const int kTweetMessageFieldNumber = 1;
  inline const ::std::string& tweetmessage() const;
  inline void set_tweetmessage(const ::std::string& value);
  inline void set_tweetmessage(const char* value);
  inline void set_tweetmessage(const char* value, size_t size);
  inline ::std::string* mutable_tweetmessage();
  inline ::std::string* release_tweetmessage();
  inline void set_allocated_tweetmessage(::std::string* tweetmessage);

  // repeated string hashtags = 2;
  inline int hashtags_size() const;
  inline void clear_hashtags();
  static const int kHashtagsFieldNumber = 2;
  inline const ::std::string& hashtags(int index) const;
  inline ::std::string* mutable_hashtags(int index);
  inline void set_hashtags(int index, const ::std::string& value);
  inline void set_hashtags(int index, const char* value);
  inline void set_hashtags(int index, const char* value, size_t size);
  inline ::std::string* add_hashtags();
  inline void add_hashtags(const ::std::string& value);
  inline void add_hashtags(const char* value);
  inline void add_hashtags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& hashtags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_hashtags();

  // repeated string imageUris = 4;
  inline int imageuris_size() const;
  inline void clear_imageuris();
  static const int kImageUrisFieldNumber = 4;
  inline const ::std::string& imageuris(int index) const;
  inline ::std::string* mutable_imageuris(int index);
  inline void set_imageuris(int index, const ::std::string& value);
  inline void set_imageuris(int index, const char* value);
  inline void set_imageuris(int index, const char* value, size_t size);
  inline ::std::string* add_imageuris();
  inline void add_imageuris(const ::std::string& value);
  inline void add_imageuris(const char* value);
  inline void add_imageuris(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& imageuris() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_imageuris();

  // optional bool withCadence = 5;
  inline bool has_withcadence() const;
  inline void clear_withcadence();
  static const int kWithCadenceFieldNumber = 5;
  inline bool withcadence() const;
  inline void set_withcadence(bool value);

  // optional bool withHeartrate = 6;
  inline bool has_withheartrate() const;
  inline void clear_withheartrate();
  static const int kWithHeartrateFieldNumber = 6;
  inline bool withheartrate() const;
  inline void set_withheartrate(bool value);

  // optional bool withSpeed = 7;
  inline bool has_withspeed() const;
  inline void clear_withspeed();
  static const int kWithSpeedFieldNumber = 7;
  inline bool withspeed() const;
  inline void set_withspeed(bool value);

  // optional bool withSpeedRecord = 8;
  inline bool has_withspeedrecord() const;
  inline void clear_withspeedrecord();
  static const int kWithSpeedRecordFieldNumber = 8;
  inline bool withspeedrecord() const;
  inline void set_withspeedrecord(bool value);

  // @@protoc_insertion_point(class_scope:eaglesakura_ace.TweetRequestPayload)
 private:
  inline void set_has_tweetmessage();
  inline void clear_has_tweetmessage();
  inline void set_has_withcadence();
  inline void clear_has_withcadence();
  inline void set_has_withheartrate();
  inline void clear_has_withheartrate();
  inline void set_has_withspeed();
  inline void clear_has_withspeed();
  inline void set_has_withspeedrecord();
  inline void clear_has_withspeedrecord();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tweetmessage_;
  ::google::protobuf::RepeatedPtrField< ::std::string> hashtags_;
  ::google::protobuf::RepeatedPtrField< ::std::string> imageuris_;
  bool withcadence_;
  bool withheartrate_;
  bool withspeed_;
  bool withspeedrecord_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_CommandProtocol_2eproto();
  friend void protobuf_AssignDesc_CommandProtocol_2eproto();
  friend void protobuf_ShutdownFile_CommandProtocol_2eproto();

  void InitAsDefaultInstance();
  static TweetRequestPayload* default_instance_;
};
// -------------------------------------------------------------------

class TriggerPayload : public ::google::protobuf::Message {
 public:
  TriggerPayload();
  virtual ~TriggerPayload();

  TriggerPayload(const TriggerPayload& from);

  inline TriggerPayload& operator=(const TriggerPayload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TriggerPayload& default_instance();

  void Swap(TriggerPayload* other);

  // implements Message ----------------------------------------------

  TriggerPayload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TriggerPayload& from);
  void MergeFrom(const TriggerPayload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .eaglesakura_ace.TriggerType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::eaglesakura_ace::TriggerType type() const;
  inline void set_type(::eaglesakura_ace::TriggerType value);

  // required string extraUniqueId = 2;
  inline bool has_extrauniqueid() const;
  inline void clear_extrauniqueid();
  static const int kExtraUniqueIdFieldNumber = 2;
  inline const ::std::string& extrauniqueid() const;
  inline void set_extrauniqueid(const ::std::string& value);
  inline void set_extrauniqueid(const char* value);
  inline void set_extrauniqueid(const char* value, size_t size);
  inline ::std::string* mutable_extrauniqueid();
  inline ::std::string* release_extrauniqueid();
  inline void set_allocated_extrauniqueid(::std::string* extrauniqueid);

  // optional int32 commandSec = 3;
  inline bool has_commandsec() const;
  inline void clear_commandsec();
  static const int kCommandSecFieldNumber = 3;
  inline ::google::protobuf::int32 commandsec() const;
  inline void set_commandsec(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:eaglesakura_ace.TriggerPayload)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_extrauniqueid();
  inline void clear_has_extrauniqueid();
  inline void set_has_commandsec();
  inline void clear_has_commandsec();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* extrauniqueid_;
  int type_;
  ::google::protobuf::int32 commandsec_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CommandProtocol_2eproto();
  friend void protobuf_AssignDesc_CommandProtocol_2eproto();
  friend void protobuf_ShutdownFile_CommandProtocol_2eproto();

  void InitAsDefaultInstance();
  static TriggerPayload* default_instance_;
};
// -------------------------------------------------------------------

class CommandPayload : public ::google::protobuf::Message {
 public:
  CommandPayload();
  virtual ~CommandPayload();

  CommandPayload(const CommandPayload& from);

  inline CommandPayload& operator=(const CommandPayload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandPayload& default_instance();

  void Swap(CommandPayload* other);

  // implements Message ----------------------------------------------

  CommandPayload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandPayload& from);
  void MergeFrom(const CommandPayload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::std::string& command() const;
  inline void set_command(const ::std::string& value);
  inline void set_command(const char* value);
  inline void set_command(const char* value, size_t size);
  inline ::std::string* mutable_command();
  inline ::std::string* release_command();
  inline void set_allocated_command(::std::string* command);

  // optional bytes extraPayload = 2;
  inline bool has_extrapayload() const;
  inline void clear_extrapayload();
  static const int kExtraPayloadFieldNumber = 2;
  inline const ::std::string& extrapayload() const;
  inline void set_extrapayload(const ::std::string& value);
  inline void set_extrapayload(const char* value);
  inline void set_extrapayload(const void* value, size_t size);
  inline ::std::string* mutable_extrapayload();
  inline ::std::string* release_extrapayload();
  inline void set_allocated_extrapayload(::std::string* extrapayload);

  // @@protoc_insertion_point(class_scope:eaglesakura_ace.CommandPayload)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_extrapayload();
  inline void clear_has_extrapayload();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* command_;
  ::std::string* extrapayload_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CommandProtocol_2eproto();
  friend void protobuf_AssignDesc_CommandProtocol_2eproto();
  friend void protobuf_ShutdownFile_CommandProtocol_2eproto();

  void InitAsDefaultInstance();
  static CommandPayload* default_instance_;
};
// ===================================================================


// ===================================================================

// CameraShotPayload

// optional string imageUri = 1;
inline bool CameraShotPayload::has_imageuri() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraShotPayload::set_has_imageuri() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraShotPayload::clear_has_imageuri() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraShotPayload::clear_imageuri() {
  if (imageuri_ != &::google::protobuf::internal::kEmptyString) {
    imageuri_->clear();
  }
  clear_has_imageuri();
}
inline const ::std::string& CameraShotPayload::imageuri() const {
  return *imageuri_;
}
inline void CameraShotPayload::set_imageuri(const ::std::string& value) {
  set_has_imageuri();
  if (imageuri_ == &::google::protobuf::internal::kEmptyString) {
    imageuri_ = new ::std::string;
  }
  imageuri_->assign(value);
}
inline void CameraShotPayload::set_imageuri(const char* value) {
  set_has_imageuri();
  if (imageuri_ == &::google::protobuf::internal::kEmptyString) {
    imageuri_ = new ::std::string;
  }
  imageuri_->assign(value);
}
inline void CameraShotPayload::set_imageuri(const char* value, size_t size) {
  set_has_imageuri();
  if (imageuri_ == &::google::protobuf::internal::kEmptyString) {
    imageuri_ = new ::std::string;
  }
  imageuri_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CameraShotPayload::mutable_imageuri() {
  set_has_imageuri();
  if (imageuri_ == &::google::protobuf::internal::kEmptyString) {
    imageuri_ = new ::std::string;
  }
  return imageuri_;
}
inline ::std::string* CameraShotPayload::release_imageuri() {
  clear_has_imageuri();
  if (imageuri_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imageuri_;
    imageuri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CameraShotPayload::set_allocated_imageuri(::std::string* imageuri) {
  if (imageuri_ != &::google::protobuf::internal::kEmptyString) {
    delete imageuri_;
  }
  if (imageuri) {
    set_has_imageuri();
    imageuri_ = imageuri;
  } else {
    clear_has_imageuri();
    imageuri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 imageWidth = 2;
inline bool CameraShotPayload::has_imagewidth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraShotPayload::set_has_imagewidth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraShotPayload::clear_has_imagewidth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraShotPayload::clear_imagewidth() {
  imagewidth_ = 0;
  clear_has_imagewidth();
}
inline ::google::protobuf::int32 CameraShotPayload::imagewidth() const {
  return imagewidth_;
}
inline void CameraShotPayload::set_imagewidth(::google::protobuf::int32 value) {
  set_has_imagewidth();
  imagewidth_ = value;
}

// required int32 imageHeight = 3;
inline bool CameraShotPayload::has_imageheight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CameraShotPayload::set_has_imageheight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CameraShotPayload::clear_has_imageheight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CameraShotPayload::clear_imageheight() {
  imageheight_ = 0;
  clear_has_imageheight();
}
inline ::google::protobuf::int32 CameraShotPayload::imageheight() const {
  return imageheight_;
}
inline void CameraShotPayload::set_imageheight(::google::protobuf::int32 value) {
  set_has_imageheight();
  imageheight_ = value;
}

// -------------------------------------------------------------------

// TweetRequestPayload

// required string tweetMessage = 1;
inline bool TweetRequestPayload::has_tweetmessage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TweetRequestPayload::set_has_tweetmessage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TweetRequestPayload::clear_has_tweetmessage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TweetRequestPayload::clear_tweetmessage() {
  if (tweetmessage_ != &::google::protobuf::internal::kEmptyString) {
    tweetmessage_->clear();
  }
  clear_has_tweetmessage();
}
inline const ::std::string& TweetRequestPayload::tweetmessage() const {
  return *tweetmessage_;
}
inline void TweetRequestPayload::set_tweetmessage(const ::std::string& value) {
  set_has_tweetmessage();
  if (tweetmessage_ == &::google::protobuf::internal::kEmptyString) {
    tweetmessage_ = new ::std::string;
  }
  tweetmessage_->assign(value);
}
inline void TweetRequestPayload::set_tweetmessage(const char* value) {
  set_has_tweetmessage();
  if (tweetmessage_ == &::google::protobuf::internal::kEmptyString) {
    tweetmessage_ = new ::std::string;
  }
  tweetmessage_->assign(value);
}
inline void TweetRequestPayload::set_tweetmessage(const char* value, size_t size) {
  set_has_tweetmessage();
  if (tweetmessage_ == &::google::protobuf::internal::kEmptyString) {
    tweetmessage_ = new ::std::string;
  }
  tweetmessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TweetRequestPayload::mutable_tweetmessage() {
  set_has_tweetmessage();
  if (tweetmessage_ == &::google::protobuf::internal::kEmptyString) {
    tweetmessage_ = new ::std::string;
  }
  return tweetmessage_;
}
inline ::std::string* TweetRequestPayload::release_tweetmessage() {
  clear_has_tweetmessage();
  if (tweetmessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tweetmessage_;
    tweetmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TweetRequestPayload::set_allocated_tweetmessage(::std::string* tweetmessage) {
  if (tweetmessage_ != &::google::protobuf::internal::kEmptyString) {
    delete tweetmessage_;
  }
  if (tweetmessage) {
    set_has_tweetmessage();
    tweetmessage_ = tweetmessage;
  } else {
    clear_has_tweetmessage();
    tweetmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string hashtags = 2;
inline int TweetRequestPayload::hashtags_size() const {
  return hashtags_.size();
}
inline void TweetRequestPayload::clear_hashtags() {
  hashtags_.Clear();
}
inline const ::std::string& TweetRequestPayload::hashtags(int index) const {
  return hashtags_.Get(index);
}
inline ::std::string* TweetRequestPayload::mutable_hashtags(int index) {
  return hashtags_.Mutable(index);
}
inline void TweetRequestPayload::set_hashtags(int index, const ::std::string& value) {
  hashtags_.Mutable(index)->assign(value);
}
inline void TweetRequestPayload::set_hashtags(int index, const char* value) {
  hashtags_.Mutable(index)->assign(value);
}
inline void TweetRequestPayload::set_hashtags(int index, const char* value, size_t size) {
  hashtags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TweetRequestPayload::add_hashtags() {
  return hashtags_.Add();
}
inline void TweetRequestPayload::add_hashtags(const ::std::string& value) {
  hashtags_.Add()->assign(value);
}
inline void TweetRequestPayload::add_hashtags(const char* value) {
  hashtags_.Add()->assign(value);
}
inline void TweetRequestPayload::add_hashtags(const char* value, size_t size) {
  hashtags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TweetRequestPayload::hashtags() const {
  return hashtags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TweetRequestPayload::mutable_hashtags() {
  return &hashtags_;
}

// repeated string imageUris = 4;
inline int TweetRequestPayload::imageuris_size() const {
  return imageuris_.size();
}
inline void TweetRequestPayload::clear_imageuris() {
  imageuris_.Clear();
}
inline const ::std::string& TweetRequestPayload::imageuris(int index) const {
  return imageuris_.Get(index);
}
inline ::std::string* TweetRequestPayload::mutable_imageuris(int index) {
  return imageuris_.Mutable(index);
}
inline void TweetRequestPayload::set_imageuris(int index, const ::std::string& value) {
  imageuris_.Mutable(index)->assign(value);
}
inline void TweetRequestPayload::set_imageuris(int index, const char* value) {
  imageuris_.Mutable(index)->assign(value);
}
inline void TweetRequestPayload::set_imageuris(int index, const char* value, size_t size) {
  imageuris_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TweetRequestPayload::add_imageuris() {
  return imageuris_.Add();
}
inline void TweetRequestPayload::add_imageuris(const ::std::string& value) {
  imageuris_.Add()->assign(value);
}
inline void TweetRequestPayload::add_imageuris(const char* value) {
  imageuris_.Add()->assign(value);
}
inline void TweetRequestPayload::add_imageuris(const char* value, size_t size) {
  imageuris_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TweetRequestPayload::imageuris() const {
  return imageuris_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TweetRequestPayload::mutable_imageuris() {
  return &imageuris_;
}

// optional bool withCadence = 5;
inline bool TweetRequestPayload::has_withcadence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TweetRequestPayload::set_has_withcadence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TweetRequestPayload::clear_has_withcadence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TweetRequestPayload::clear_withcadence() {
  withcadence_ = false;
  clear_has_withcadence();
}
inline bool TweetRequestPayload::withcadence() const {
  return withcadence_;
}
inline void TweetRequestPayload::set_withcadence(bool value) {
  set_has_withcadence();
  withcadence_ = value;
}

// optional bool withHeartrate = 6;
inline bool TweetRequestPayload::has_withheartrate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TweetRequestPayload::set_has_withheartrate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TweetRequestPayload::clear_has_withheartrate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TweetRequestPayload::clear_withheartrate() {
  withheartrate_ = false;
  clear_has_withheartrate();
}
inline bool TweetRequestPayload::withheartrate() const {
  return withheartrate_;
}
inline void TweetRequestPayload::set_withheartrate(bool value) {
  set_has_withheartrate();
  withheartrate_ = value;
}

// optional bool withSpeed = 7;
inline bool TweetRequestPayload::has_withspeed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TweetRequestPayload::set_has_withspeed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TweetRequestPayload::clear_has_withspeed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TweetRequestPayload::clear_withspeed() {
  withspeed_ = false;
  clear_has_withspeed();
}
inline bool TweetRequestPayload::withspeed() const {
  return withspeed_;
}
inline void TweetRequestPayload::set_withspeed(bool value) {
  set_has_withspeed();
  withspeed_ = value;
}

// optional bool withSpeedRecord = 8;
inline bool TweetRequestPayload::has_withspeedrecord() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TweetRequestPayload::set_has_withspeedrecord() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TweetRequestPayload::clear_has_withspeedrecord() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TweetRequestPayload::clear_withspeedrecord() {
  withspeedrecord_ = false;
  clear_has_withspeedrecord();
}
inline bool TweetRequestPayload::withspeedrecord() const {
  return withspeedrecord_;
}
inline void TweetRequestPayload::set_withspeedrecord(bool value) {
  set_has_withspeedrecord();
  withspeedrecord_ = value;
}

// -------------------------------------------------------------------

// TriggerPayload

// required .eaglesakura_ace.TriggerType type = 1;
inline bool TriggerPayload::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TriggerPayload::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TriggerPayload::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TriggerPayload::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::eaglesakura_ace::TriggerType TriggerPayload::type() const {
  return static_cast< ::eaglesakura_ace::TriggerType >(type_);
}
inline void TriggerPayload::set_type(::eaglesakura_ace::TriggerType value) {
  assert(::eaglesakura_ace::TriggerType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string extraUniqueId = 2;
inline bool TriggerPayload::has_extrauniqueid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TriggerPayload::set_has_extrauniqueid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TriggerPayload::clear_has_extrauniqueid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TriggerPayload::clear_extrauniqueid() {
  if (extrauniqueid_ != &::google::protobuf::internal::kEmptyString) {
    extrauniqueid_->clear();
  }
  clear_has_extrauniqueid();
}
inline const ::std::string& TriggerPayload::extrauniqueid() const {
  return *extrauniqueid_;
}
inline void TriggerPayload::set_extrauniqueid(const ::std::string& value) {
  set_has_extrauniqueid();
  if (extrauniqueid_ == &::google::protobuf::internal::kEmptyString) {
    extrauniqueid_ = new ::std::string;
  }
  extrauniqueid_->assign(value);
}
inline void TriggerPayload::set_extrauniqueid(const char* value) {
  set_has_extrauniqueid();
  if (extrauniqueid_ == &::google::protobuf::internal::kEmptyString) {
    extrauniqueid_ = new ::std::string;
  }
  extrauniqueid_->assign(value);
}
inline void TriggerPayload::set_extrauniqueid(const char* value, size_t size) {
  set_has_extrauniqueid();
  if (extrauniqueid_ == &::google::protobuf::internal::kEmptyString) {
    extrauniqueid_ = new ::std::string;
  }
  extrauniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TriggerPayload::mutable_extrauniqueid() {
  set_has_extrauniqueid();
  if (extrauniqueid_ == &::google::protobuf::internal::kEmptyString) {
    extrauniqueid_ = new ::std::string;
  }
  return extrauniqueid_;
}
inline ::std::string* TriggerPayload::release_extrauniqueid() {
  clear_has_extrauniqueid();
  if (extrauniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extrauniqueid_;
    extrauniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TriggerPayload::set_allocated_extrauniqueid(::std::string* extrauniqueid) {
  if (extrauniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete extrauniqueid_;
  }
  if (extrauniqueid) {
    set_has_extrauniqueid();
    extrauniqueid_ = extrauniqueid;
  } else {
    clear_has_extrauniqueid();
    extrauniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 commandSec = 3;
inline bool TriggerPayload::has_commandsec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TriggerPayload::set_has_commandsec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TriggerPayload::clear_has_commandsec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TriggerPayload::clear_commandsec() {
  commandsec_ = 0;
  clear_has_commandsec();
}
inline ::google::protobuf::int32 TriggerPayload::commandsec() const {
  return commandsec_;
}
inline void TriggerPayload::set_commandsec(::google::protobuf::int32 value) {
  set_has_commandsec();
  commandsec_ = value;
}

// -------------------------------------------------------------------

// CommandPayload

// required string command = 1;
inline bool CommandPayload::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandPayload::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandPayload::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandPayload::clear_command() {
  if (command_ != &::google::protobuf::internal::kEmptyString) {
    command_->clear();
  }
  clear_has_command();
}
inline const ::std::string& CommandPayload::command() const {
  return *command_;
}
inline void CommandPayload::set_command(const ::std::string& value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void CommandPayload::set_command(const char* value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void CommandPayload::set_command(const char* value, size_t size) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    command_ = new ::std::string;
  }
  command_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandPayload::mutable_command() {
  set_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    command_ = new ::std::string;
  }
  return command_;
}
inline ::std::string* CommandPayload::release_command() {
  clear_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = command_;
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandPayload::set_allocated_command(::std::string* command) {
  if (command_ != &::google::protobuf::internal::kEmptyString) {
    delete command_;
  }
  if (command) {
    set_has_command();
    command_ = command;
  } else {
    clear_has_command();
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes extraPayload = 2;
inline bool CommandPayload::has_extrapayload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandPayload::set_has_extrapayload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandPayload::clear_has_extrapayload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandPayload::clear_extrapayload() {
  if (extrapayload_ != &::google::protobuf::internal::kEmptyString) {
    extrapayload_->clear();
  }
  clear_has_extrapayload();
}
inline const ::std::string& CommandPayload::extrapayload() const {
  return *extrapayload_;
}
inline void CommandPayload::set_extrapayload(const ::std::string& value) {
  set_has_extrapayload();
  if (extrapayload_ == &::google::protobuf::internal::kEmptyString) {
    extrapayload_ = new ::std::string;
  }
  extrapayload_->assign(value);
}
inline void CommandPayload::set_extrapayload(const char* value) {
  set_has_extrapayload();
  if (extrapayload_ == &::google::protobuf::internal::kEmptyString) {
    extrapayload_ = new ::std::string;
  }
  extrapayload_->assign(value);
}
inline void CommandPayload::set_extrapayload(const void* value, size_t size) {
  set_has_extrapayload();
  if (extrapayload_ == &::google::protobuf::internal::kEmptyString) {
    extrapayload_ = new ::std::string;
  }
  extrapayload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandPayload::mutable_extrapayload() {
  set_has_extrapayload();
  if (extrapayload_ == &::google::protobuf::internal::kEmptyString) {
    extrapayload_ = new ::std::string;
  }
  return extrapayload_;
}
inline ::std::string* CommandPayload::release_extrapayload() {
  clear_has_extrapayload();
  if (extrapayload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extrapayload_;
    extrapayload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandPayload::set_allocated_extrapayload(::std::string* extrapayload) {
  if (extrapayload_ != &::google::protobuf::internal::kEmptyString) {
    delete extrapayload_;
  }
  if (extrapayload) {
    set_has_extrapayload();
    extrapayload_ = extrapayload;
  } else {
    clear_has_extrapayload();
    extrapayload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace eaglesakura_ace

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eaglesakura_ace::CommandType>() {
  return ::eaglesakura_ace::CommandType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eaglesakura_ace::TriggerType>() {
  return ::eaglesakura_ace::TriggerType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eaglesakura_ace::AcesControllCommand>() {
  return ::eaglesakura_ace::AcesControllCommand_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CommandProtocol_2eproto__INCLUDED

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CommandProtocol.proto

#ifndef PROTOBUF_CommandProtocol_2eproto__INCLUDED
#define PROTOBUF_CommandProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "AceConstants.pb.h"
// @@protoc_insertion_point(includes)

namespace eaglesakura_ace {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CommandProtocol_2eproto();
void protobuf_AssignDesc_CommandProtocol_2eproto();
void protobuf_ShutdownFile_CommandProtocol_2eproto();

class CameraShotPayload;
class TweetControllPayload;
class ProximityControllPayload;
class CommandPayload;

enum Command {
  CameraShotRequest = 2,
  CameraShotData = 3,
  TweetControll = 4,
  ProximityControll = 5
};
bool Command_IsValid(int value);
const Command Command_MIN = CameraShotRequest;
const Command Command_MAX = ProximityControll;
const int Command_ARRAYSIZE = Command_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_descriptor();
inline const ::std::string& Command_Name(Command value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_descriptor(), value);
}
inline bool Command_Parse(
    const ::std::string& name, Command* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command>(
    Command_descriptor(), name, value);
}
// ===================================================================

class CameraShotPayload : public ::google::protobuf::Message {
 public:
  CameraShotPayload();
  virtual ~CameraShotPayload();

  CameraShotPayload(const CameraShotPayload& from);

  inline CameraShotPayload& operator=(const CameraShotPayload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraShotPayload& default_instance();

  void Swap(CameraShotPayload* other);

  // implements Message ----------------------------------------------

  CameraShotPayload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraShotPayload& from);
  void MergeFrom(const CameraShotPayload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes imageFile = 1;
  inline bool has_imagefile() const;
  inline void clear_imagefile();
  static const int kImageFileFieldNumber = 1;
  inline const ::std::string& imagefile() const;
  inline void set_imagefile(const ::std::string& value);
  inline void set_imagefile(const char* value);
  inline void set_imagefile(const void* value, size_t size);
  inline ::std::string* mutable_imagefile();
  inline ::std::string* release_imagefile();
  inline void set_allocated_imagefile(::std::string* imagefile);

  // required int32 imageWidth = 2;
  inline bool has_imagewidth() const;
  inline void clear_imagewidth();
  static const int kImageWidthFieldNumber = 2;
  inline ::google::protobuf::int32 imagewidth() const;
  inline void set_imagewidth(::google::protobuf::int32 value);

  // required int32 imageHeight = 3;
  inline bool has_imageheight() const;
  inline void clear_imageheight();
  static const int kImageHeightFieldNumber = 3;
  inline ::google::protobuf::int32 imageheight() const;
  inline void set_imageheight(::google::protobuf::int32 value);

  // required string imageId = 4;
  inline bool has_imageid() const;
  inline void clear_imageid();
  static const int kImageIdFieldNumber = 4;
  inline const ::std::string& imageid() const;
  inline void set_imageid(const ::std::string& value);
  inline void set_imageid(const char* value);
  inline void set_imageid(const char* value, size_t size);
  inline ::std::string* mutable_imageid();
  inline ::std::string* release_imageid();
  inline void set_allocated_imageid(::std::string* imageid);

  // @@protoc_insertion_point(class_scope:eaglesakura_ace.CameraShotPayload)
 private:
  inline void set_has_imagefile();
  inline void clear_has_imagefile();
  inline void set_has_imagewidth();
  inline void clear_has_imagewidth();
  inline void set_has_imageheight();
  inline void clear_has_imageheight();
  inline void set_has_imageid();
  inline void clear_has_imageid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* imagefile_;
  ::google::protobuf::int32 imagewidth_;
  ::google::protobuf::int32 imageheight_;
  ::std::string* imageid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CommandProtocol_2eproto();
  friend void protobuf_AssignDesc_CommandProtocol_2eproto();
  friend void protobuf_ShutdownFile_CommandProtocol_2eproto();

  void InitAsDefaultInstance();
  static CameraShotPayload* default_instance_;
};
// -------------------------------------------------------------------

class TweetControllPayload : public ::google::protobuf::Message {
 public:
  TweetControllPayload();
  virtual ~TweetControllPayload();

  TweetControllPayload(const TweetControllPayload& from);

  inline TweetControllPayload& operator=(const TweetControllPayload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TweetControllPayload& default_instance();

  void Swap(TweetControllPayload* other);

  // implements Message ----------------------------------------------

  TweetControllPayload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TweetControllPayload& from);
  void MergeFrom(const TweetControllPayload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string tweetMessage = 1;
  inline bool has_tweetmessage() const;
  inline void clear_tweetmessage();
  static const int kTweetMessageFieldNumber = 1;
  inline const ::std::string& tweetmessage() const;
  inline void set_tweetmessage(const ::std::string& value);
  inline void set_tweetmessage(const char* value);
  inline void set_tweetmessage(const char* value, size_t size);
  inline ::std::string* mutable_tweetmessage();
  inline ::std::string* release_tweetmessage();
  inline void set_allocated_tweetmessage(::std::string* tweetmessage);

  // repeated string hashtags = 2;
  inline int hashtags_size() const;
  inline void clear_hashtags();
  static const int kHashtagsFieldNumber = 2;
  inline const ::std::string& hashtags(int index) const;
  inline ::std::string* mutable_hashtags(int index);
  inline void set_hashtags(int index, const ::std::string& value);
  inline void set_hashtags(int index, const char* value);
  inline void set_hashtags(int index, const char* value, size_t size);
  inline ::std::string* add_hashtags();
  inline void add_hashtags(const ::std::string& value);
  inline void add_hashtags(const char* value);
  inline void add_hashtags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& hashtags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_hashtags();

  // repeated bytes rawImageFiles = 3;
  inline int rawimagefiles_size() const;
  inline void clear_rawimagefiles();
  static const int kRawImageFilesFieldNumber = 3;
  inline const ::std::string& rawimagefiles(int index) const;
  inline ::std::string* mutable_rawimagefiles(int index);
  inline void set_rawimagefiles(int index, const ::std::string& value);
  inline void set_rawimagefiles(int index, const char* value);
  inline void set_rawimagefiles(int index, const void* value, size_t size);
  inline ::std::string* add_rawimagefiles();
  inline void add_rawimagefiles(const ::std::string& value);
  inline void add_rawimagefiles(const char* value);
  inline void add_rawimagefiles(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& rawimagefiles() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_rawimagefiles();

  // repeated string imageUris = 4;
  inline int imageuris_size() const;
  inline void clear_imageuris();
  static const int kImageUrisFieldNumber = 4;
  inline const ::std::string& imageuris(int index) const;
  inline ::std::string* mutable_imageuris(int index);
  inline void set_imageuris(int index, const ::std::string& value);
  inline void set_imageuris(int index, const char* value);
  inline void set_imageuris(int index, const char* value, size_t size);
  inline ::std::string* add_imageuris();
  inline void add_imageuris(const ::std::string& value);
  inline void add_imageuris(const char* value);
  inline void add_imageuris(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& imageuris() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_imageuris();

  // @@protoc_insertion_point(class_scope:eaglesakura_ace.TweetControllPayload)
 private:
  inline void set_has_tweetmessage();
  inline void clear_has_tweetmessage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tweetmessage_;
  ::google::protobuf::RepeatedPtrField< ::std::string> hashtags_;
  ::google::protobuf::RepeatedPtrField< ::std::string> rawimagefiles_;
  ::google::protobuf::RepeatedPtrField< ::std::string> imageuris_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CommandProtocol_2eproto();
  friend void protobuf_AssignDesc_CommandProtocol_2eproto();
  friend void protobuf_ShutdownFile_CommandProtocol_2eproto();

  void InitAsDefaultInstance();
  static TweetControllPayload* default_instance_;
};
// -------------------------------------------------------------------

class ProximityControllPayload : public ::google::protobuf::Message {
 public:
  ProximityControllPayload();
  virtual ~ProximityControllPayload();

  ProximityControllPayload(const ProximityControllPayload& from);

  inline ProximityControllPayload& operator=(const ProximityControllPayload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProximityControllPayload& default_instance();

  void Swap(ProximityControllPayload* other);

  // implements Message ----------------------------------------------

  ProximityControllPayload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProximityControllPayload& from);
  void MergeFrom(const ProximityControllPayload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 commandSec = 1;
  inline bool has_commandsec() const;
  inline void clear_commandsec();
  static const int kCommandSecFieldNumber = 1;
  inline ::google::protobuf::int32 commandsec() const;
  inline void set_commandsec(::google::protobuf::int32 value);

  // required string extraUniqueId = 2;
  inline bool has_extrauniqueid() const;
  inline void clear_extrauniqueid();
  static const int kExtraUniqueIdFieldNumber = 2;
  inline const ::std::string& extrauniqueid() const;
  inline void set_extrauniqueid(const ::std::string& value);
  inline void set_extrauniqueid(const char* value);
  inline void set_extrauniqueid(const char* value, size_t size);
  inline ::std::string* mutable_extrauniqueid();
  inline ::std::string* release_extrauniqueid();
  inline void set_allocated_extrauniqueid(::std::string* extrauniqueid);

  // @@protoc_insertion_point(class_scope:eaglesakura_ace.ProximityControllPayload)
 private:
  inline void set_has_commandsec();
  inline void clear_has_commandsec();
  inline void set_has_extrauniqueid();
  inline void clear_has_extrauniqueid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* extrauniqueid_;
  ::google::protobuf::int32 commandsec_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CommandProtocol_2eproto();
  friend void protobuf_AssignDesc_CommandProtocol_2eproto();
  friend void protobuf_ShutdownFile_CommandProtocol_2eproto();

  void InitAsDefaultInstance();
  static ProximityControllPayload* default_instance_;
};
// -------------------------------------------------------------------

class CommandPayload : public ::google::protobuf::Message {
 public:
  CommandPayload();
  virtual ~CommandPayload();

  CommandPayload(const CommandPayload& from);

  inline CommandPayload& operator=(const CommandPayload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandPayload& default_instance();

  void Swap(CommandPayload* other);

  // implements Message ----------------------------------------------

  CommandPayload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandPayload& from);
  void MergeFrom(const CommandPayload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::std::string& command() const;
  inline void set_command(const ::std::string& value);
  inline void set_command(const char* value);
  inline void set_command(const char* value, size_t size);
  inline ::std::string* mutable_command();
  inline ::std::string* release_command();
  inline void set_allocated_command(::std::string* command);

  // optional bytes extraPayload = 2;
  inline bool has_extrapayload() const;
  inline void clear_extrapayload();
  static const int kExtraPayloadFieldNumber = 2;
  inline const ::std::string& extrapayload() const;
  inline void set_extrapayload(const ::std::string& value);
  inline void set_extrapayload(const char* value);
  inline void set_extrapayload(const void* value, size_t size);
  inline ::std::string* mutable_extrapayload();
  inline ::std::string* release_extrapayload();
  inline void set_allocated_extrapayload(::std::string* extrapayload);

  // @@protoc_insertion_point(class_scope:eaglesakura_ace.CommandPayload)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_extrapayload();
  inline void clear_has_extrapayload();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* command_;
  ::std::string* extrapayload_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CommandProtocol_2eproto();
  friend void protobuf_AssignDesc_CommandProtocol_2eproto();
  friend void protobuf_ShutdownFile_CommandProtocol_2eproto();

  void InitAsDefaultInstance();
  static CommandPayload* default_instance_;
};
// ===================================================================


// ===================================================================

// CameraShotPayload

// optional bytes imageFile = 1;
inline bool CameraShotPayload::has_imagefile() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraShotPayload::set_has_imagefile() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraShotPayload::clear_has_imagefile() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraShotPayload::clear_imagefile() {
  if (imagefile_ != &::google::protobuf::internal::kEmptyString) {
    imagefile_->clear();
  }
  clear_has_imagefile();
}
inline const ::std::string& CameraShotPayload::imagefile() const {
  return *imagefile_;
}
inline void CameraShotPayload::set_imagefile(const ::std::string& value) {
  set_has_imagefile();
  if (imagefile_ == &::google::protobuf::internal::kEmptyString) {
    imagefile_ = new ::std::string;
  }
  imagefile_->assign(value);
}
inline void CameraShotPayload::set_imagefile(const char* value) {
  set_has_imagefile();
  if (imagefile_ == &::google::protobuf::internal::kEmptyString) {
    imagefile_ = new ::std::string;
  }
  imagefile_->assign(value);
}
inline void CameraShotPayload::set_imagefile(const void* value, size_t size) {
  set_has_imagefile();
  if (imagefile_ == &::google::protobuf::internal::kEmptyString) {
    imagefile_ = new ::std::string;
  }
  imagefile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CameraShotPayload::mutable_imagefile() {
  set_has_imagefile();
  if (imagefile_ == &::google::protobuf::internal::kEmptyString) {
    imagefile_ = new ::std::string;
  }
  return imagefile_;
}
inline ::std::string* CameraShotPayload::release_imagefile() {
  clear_has_imagefile();
  if (imagefile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imagefile_;
    imagefile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CameraShotPayload::set_allocated_imagefile(::std::string* imagefile) {
  if (imagefile_ != &::google::protobuf::internal::kEmptyString) {
    delete imagefile_;
  }
  if (imagefile) {
    set_has_imagefile();
    imagefile_ = imagefile;
  } else {
    clear_has_imagefile();
    imagefile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 imageWidth = 2;
inline bool CameraShotPayload::has_imagewidth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraShotPayload::set_has_imagewidth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraShotPayload::clear_has_imagewidth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraShotPayload::clear_imagewidth() {
  imagewidth_ = 0;
  clear_has_imagewidth();
}
inline ::google::protobuf::int32 CameraShotPayload::imagewidth() const {
  return imagewidth_;
}
inline void CameraShotPayload::set_imagewidth(::google::protobuf::int32 value) {
  set_has_imagewidth();
  imagewidth_ = value;
}

// required int32 imageHeight = 3;
inline bool CameraShotPayload::has_imageheight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CameraShotPayload::set_has_imageheight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CameraShotPayload::clear_has_imageheight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CameraShotPayload::clear_imageheight() {
  imageheight_ = 0;
  clear_has_imageheight();
}
inline ::google::protobuf::int32 CameraShotPayload::imageheight() const {
  return imageheight_;
}
inline void CameraShotPayload::set_imageheight(::google::protobuf::int32 value) {
  set_has_imageheight();
  imageheight_ = value;
}

// required string imageId = 4;
inline bool CameraShotPayload::has_imageid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CameraShotPayload::set_has_imageid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CameraShotPayload::clear_has_imageid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CameraShotPayload::clear_imageid() {
  if (imageid_ != &::google::protobuf::internal::kEmptyString) {
    imageid_->clear();
  }
  clear_has_imageid();
}
inline const ::std::string& CameraShotPayload::imageid() const {
  return *imageid_;
}
inline void CameraShotPayload::set_imageid(const ::std::string& value) {
  set_has_imageid();
  if (imageid_ == &::google::protobuf::internal::kEmptyString) {
    imageid_ = new ::std::string;
  }
  imageid_->assign(value);
}
inline void CameraShotPayload::set_imageid(const char* value) {
  set_has_imageid();
  if (imageid_ == &::google::protobuf::internal::kEmptyString) {
    imageid_ = new ::std::string;
  }
  imageid_->assign(value);
}
inline void CameraShotPayload::set_imageid(const char* value, size_t size) {
  set_has_imageid();
  if (imageid_ == &::google::protobuf::internal::kEmptyString) {
    imageid_ = new ::std::string;
  }
  imageid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CameraShotPayload::mutable_imageid() {
  set_has_imageid();
  if (imageid_ == &::google::protobuf::internal::kEmptyString) {
    imageid_ = new ::std::string;
  }
  return imageid_;
}
inline ::std::string* CameraShotPayload::release_imageid() {
  clear_has_imageid();
  if (imageid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imageid_;
    imageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CameraShotPayload::set_allocated_imageid(::std::string* imageid) {
  if (imageid_ != &::google::protobuf::internal::kEmptyString) {
    delete imageid_;
  }
  if (imageid) {
    set_has_imageid();
    imageid_ = imageid;
  } else {
    clear_has_imageid();
    imageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TweetControllPayload

// required string tweetMessage = 1;
inline bool TweetControllPayload::has_tweetmessage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TweetControllPayload::set_has_tweetmessage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TweetControllPayload::clear_has_tweetmessage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TweetControllPayload::clear_tweetmessage() {
  if (tweetmessage_ != &::google::protobuf::internal::kEmptyString) {
    tweetmessage_->clear();
  }
  clear_has_tweetmessage();
}
inline const ::std::string& TweetControllPayload::tweetmessage() const {
  return *tweetmessage_;
}
inline void TweetControllPayload::set_tweetmessage(const ::std::string& value) {
  set_has_tweetmessage();
  if (tweetmessage_ == &::google::protobuf::internal::kEmptyString) {
    tweetmessage_ = new ::std::string;
  }
  tweetmessage_->assign(value);
}
inline void TweetControllPayload::set_tweetmessage(const char* value) {
  set_has_tweetmessage();
  if (tweetmessage_ == &::google::protobuf::internal::kEmptyString) {
    tweetmessage_ = new ::std::string;
  }
  tweetmessage_->assign(value);
}
inline void TweetControllPayload::set_tweetmessage(const char* value, size_t size) {
  set_has_tweetmessage();
  if (tweetmessage_ == &::google::protobuf::internal::kEmptyString) {
    tweetmessage_ = new ::std::string;
  }
  tweetmessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TweetControllPayload::mutable_tweetmessage() {
  set_has_tweetmessage();
  if (tweetmessage_ == &::google::protobuf::internal::kEmptyString) {
    tweetmessage_ = new ::std::string;
  }
  return tweetmessage_;
}
inline ::std::string* TweetControllPayload::release_tweetmessage() {
  clear_has_tweetmessage();
  if (tweetmessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tweetmessage_;
    tweetmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TweetControllPayload::set_allocated_tweetmessage(::std::string* tweetmessage) {
  if (tweetmessage_ != &::google::protobuf::internal::kEmptyString) {
    delete tweetmessage_;
  }
  if (tweetmessage) {
    set_has_tweetmessage();
    tweetmessage_ = tweetmessage;
  } else {
    clear_has_tweetmessage();
    tweetmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string hashtags = 2;
inline int TweetControllPayload::hashtags_size() const {
  return hashtags_.size();
}
inline void TweetControllPayload::clear_hashtags() {
  hashtags_.Clear();
}
inline const ::std::string& TweetControllPayload::hashtags(int index) const {
  return hashtags_.Get(index);
}
inline ::std::string* TweetControllPayload::mutable_hashtags(int index) {
  return hashtags_.Mutable(index);
}
inline void TweetControllPayload::set_hashtags(int index, const ::std::string& value) {
  hashtags_.Mutable(index)->assign(value);
}
inline void TweetControllPayload::set_hashtags(int index, const char* value) {
  hashtags_.Mutable(index)->assign(value);
}
inline void TweetControllPayload::set_hashtags(int index, const char* value, size_t size) {
  hashtags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TweetControllPayload::add_hashtags() {
  return hashtags_.Add();
}
inline void TweetControllPayload::add_hashtags(const ::std::string& value) {
  hashtags_.Add()->assign(value);
}
inline void TweetControllPayload::add_hashtags(const char* value) {
  hashtags_.Add()->assign(value);
}
inline void TweetControllPayload::add_hashtags(const char* value, size_t size) {
  hashtags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TweetControllPayload::hashtags() const {
  return hashtags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TweetControllPayload::mutable_hashtags() {
  return &hashtags_;
}

// repeated bytes rawImageFiles = 3;
inline int TweetControllPayload::rawimagefiles_size() const {
  return rawimagefiles_.size();
}
inline void TweetControllPayload::clear_rawimagefiles() {
  rawimagefiles_.Clear();
}
inline const ::std::string& TweetControllPayload::rawimagefiles(int index) const {
  return rawimagefiles_.Get(index);
}
inline ::std::string* TweetControllPayload::mutable_rawimagefiles(int index) {
  return rawimagefiles_.Mutable(index);
}
inline void TweetControllPayload::set_rawimagefiles(int index, const ::std::string& value) {
  rawimagefiles_.Mutable(index)->assign(value);
}
inline void TweetControllPayload::set_rawimagefiles(int index, const char* value) {
  rawimagefiles_.Mutable(index)->assign(value);
}
inline void TweetControllPayload::set_rawimagefiles(int index, const void* value, size_t size) {
  rawimagefiles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TweetControllPayload::add_rawimagefiles() {
  return rawimagefiles_.Add();
}
inline void TweetControllPayload::add_rawimagefiles(const ::std::string& value) {
  rawimagefiles_.Add()->assign(value);
}
inline void TweetControllPayload::add_rawimagefiles(const char* value) {
  rawimagefiles_.Add()->assign(value);
}
inline void TweetControllPayload::add_rawimagefiles(const void* value, size_t size) {
  rawimagefiles_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TweetControllPayload::rawimagefiles() const {
  return rawimagefiles_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TweetControllPayload::mutable_rawimagefiles() {
  return &rawimagefiles_;
}

// repeated string imageUris = 4;
inline int TweetControllPayload::imageuris_size() const {
  return imageuris_.size();
}
inline void TweetControllPayload::clear_imageuris() {
  imageuris_.Clear();
}
inline const ::std::string& TweetControllPayload::imageuris(int index) const {
  return imageuris_.Get(index);
}
inline ::std::string* TweetControllPayload::mutable_imageuris(int index) {
  return imageuris_.Mutable(index);
}
inline void TweetControllPayload::set_imageuris(int index, const ::std::string& value) {
  imageuris_.Mutable(index)->assign(value);
}
inline void TweetControllPayload::set_imageuris(int index, const char* value) {
  imageuris_.Mutable(index)->assign(value);
}
inline void TweetControllPayload::set_imageuris(int index, const char* value, size_t size) {
  imageuris_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TweetControllPayload::add_imageuris() {
  return imageuris_.Add();
}
inline void TweetControllPayload::add_imageuris(const ::std::string& value) {
  imageuris_.Add()->assign(value);
}
inline void TweetControllPayload::add_imageuris(const char* value) {
  imageuris_.Add()->assign(value);
}
inline void TweetControllPayload::add_imageuris(const char* value, size_t size) {
  imageuris_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TweetControllPayload::imageuris() const {
  return imageuris_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TweetControllPayload::mutable_imageuris() {
  return &imageuris_;
}

// -------------------------------------------------------------------

// ProximityControllPayload

// required int32 commandSec = 1;
inline bool ProximityControllPayload::has_commandsec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProximityControllPayload::set_has_commandsec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProximityControllPayload::clear_has_commandsec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProximityControllPayload::clear_commandsec() {
  commandsec_ = 0;
  clear_has_commandsec();
}
inline ::google::protobuf::int32 ProximityControllPayload::commandsec() const {
  return commandsec_;
}
inline void ProximityControllPayload::set_commandsec(::google::protobuf::int32 value) {
  set_has_commandsec();
  commandsec_ = value;
}

// required string extraUniqueId = 2;
inline bool ProximityControllPayload::has_extrauniqueid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProximityControllPayload::set_has_extrauniqueid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProximityControllPayload::clear_has_extrauniqueid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProximityControllPayload::clear_extrauniqueid() {
  if (extrauniqueid_ != &::google::protobuf::internal::kEmptyString) {
    extrauniqueid_->clear();
  }
  clear_has_extrauniqueid();
}
inline const ::std::string& ProximityControllPayload::extrauniqueid() const {
  return *extrauniqueid_;
}
inline void ProximityControllPayload::set_extrauniqueid(const ::std::string& value) {
  set_has_extrauniqueid();
  if (extrauniqueid_ == &::google::protobuf::internal::kEmptyString) {
    extrauniqueid_ = new ::std::string;
  }
  extrauniqueid_->assign(value);
}
inline void ProximityControllPayload::set_extrauniqueid(const char* value) {
  set_has_extrauniqueid();
  if (extrauniqueid_ == &::google::protobuf::internal::kEmptyString) {
    extrauniqueid_ = new ::std::string;
  }
  extrauniqueid_->assign(value);
}
inline void ProximityControllPayload::set_extrauniqueid(const char* value, size_t size) {
  set_has_extrauniqueid();
  if (extrauniqueid_ == &::google::protobuf::internal::kEmptyString) {
    extrauniqueid_ = new ::std::string;
  }
  extrauniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProximityControllPayload::mutable_extrauniqueid() {
  set_has_extrauniqueid();
  if (extrauniqueid_ == &::google::protobuf::internal::kEmptyString) {
    extrauniqueid_ = new ::std::string;
  }
  return extrauniqueid_;
}
inline ::std::string* ProximityControllPayload::release_extrauniqueid() {
  clear_has_extrauniqueid();
  if (extrauniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extrauniqueid_;
    extrauniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProximityControllPayload::set_allocated_extrauniqueid(::std::string* extrauniqueid) {
  if (extrauniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete extrauniqueid_;
  }
  if (extrauniqueid) {
    set_has_extrauniqueid();
    extrauniqueid_ = extrauniqueid;
  } else {
    clear_has_extrauniqueid();
    extrauniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CommandPayload

// required string command = 1;
inline bool CommandPayload::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandPayload::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandPayload::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandPayload::clear_command() {
  if (command_ != &::google::protobuf::internal::kEmptyString) {
    command_->clear();
  }
  clear_has_command();
}
inline const ::std::string& CommandPayload::command() const {
  return *command_;
}
inline void CommandPayload::set_command(const ::std::string& value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void CommandPayload::set_command(const char* value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    command_ = new ::std::string;
  }
  command_->assign(value);
}
inline void CommandPayload::set_command(const char* value, size_t size) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    command_ = new ::std::string;
  }
  command_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandPayload::mutable_command() {
  set_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    command_ = new ::std::string;
  }
  return command_;
}
inline ::std::string* CommandPayload::release_command() {
  clear_has_command();
  if (command_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = command_;
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandPayload::set_allocated_command(::std::string* command) {
  if (command_ != &::google::protobuf::internal::kEmptyString) {
    delete command_;
  }
  if (command) {
    set_has_command();
    command_ = command;
  } else {
    clear_has_command();
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes extraPayload = 2;
inline bool CommandPayload::has_extrapayload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandPayload::set_has_extrapayload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandPayload::clear_has_extrapayload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandPayload::clear_extrapayload() {
  if (extrapayload_ != &::google::protobuf::internal::kEmptyString) {
    extrapayload_->clear();
  }
  clear_has_extrapayload();
}
inline const ::std::string& CommandPayload::extrapayload() const {
  return *extrapayload_;
}
inline void CommandPayload::set_extrapayload(const ::std::string& value) {
  set_has_extrapayload();
  if (extrapayload_ == &::google::protobuf::internal::kEmptyString) {
    extrapayload_ = new ::std::string;
  }
  extrapayload_->assign(value);
}
inline void CommandPayload::set_extrapayload(const char* value) {
  set_has_extrapayload();
  if (extrapayload_ == &::google::protobuf::internal::kEmptyString) {
    extrapayload_ = new ::std::string;
  }
  extrapayload_->assign(value);
}
inline void CommandPayload::set_extrapayload(const void* value, size_t size) {
  set_has_extrapayload();
  if (extrapayload_ == &::google::protobuf::internal::kEmptyString) {
    extrapayload_ = new ::std::string;
  }
  extrapayload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandPayload::mutable_extrapayload() {
  set_has_extrapayload();
  if (extrapayload_ == &::google::protobuf::internal::kEmptyString) {
    extrapayload_ = new ::std::string;
  }
  return extrapayload_;
}
inline ::std::string* CommandPayload::release_extrapayload() {
  clear_has_extrapayload();
  if (extrapayload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extrapayload_;
    extrapayload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandPayload::set_allocated_extrapayload(::std::string* extrapayload) {
  if (extrapayload_ != &::google::protobuf::internal::kEmptyString) {
    delete extrapayload_;
  }
  if (extrapayload) {
    set_has_extrapayload();
    extrapayload_ = extrapayload;
  } else {
    clear_has_extrapayload();
    extrapayload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace eaglesakura_ace

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eaglesakura_ace::Command>() {
  return ::eaglesakura_ace::Command_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CommandProtocol_2eproto__INCLUDED

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SensorProtocol.proto

#ifndef PROTOBUF_SensorProtocol_2eproto__INCLUDED
#define PROTOBUF_SensorProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace eaglesakura_ace {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SensorProtocol_2eproto();
void protobuf_AssignDesc_SensorProtocol_2eproto();
void protobuf_ShutdownFile_SensorProtocol_2eproto();

class Extensions;
class RawCadence;
class RawHeartrate;

enum RawCadence_CadenceZone {
  RawCadence_CadenceZone_Easy = 0,
  RawCadence_CadenceZone_Beginner = 1,
  RawCadence_CadenceZone_Ideal = 2
};
bool RawCadence_CadenceZone_IsValid(int value);
const RawCadence_CadenceZone RawCadence_CadenceZone_CadenceZone_MIN = RawCadence_CadenceZone_Easy;
const RawCadence_CadenceZone RawCadence_CadenceZone_CadenceZone_MAX = RawCadence_CadenceZone_Ideal;
const int RawCadence_CadenceZone_CadenceZone_ARRAYSIZE = RawCadence_CadenceZone_CadenceZone_MAX + 1;

const ::google::protobuf::EnumDescriptor* RawCadence_CadenceZone_descriptor();
inline const ::std::string& RawCadence_CadenceZone_Name(RawCadence_CadenceZone value) {
  return ::google::protobuf::internal::NameOfEnum(
    RawCadence_CadenceZone_descriptor(), value);
}
inline bool RawCadence_CadenceZone_Parse(
    const ::std::string& name, RawCadence_CadenceZone* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RawCadence_CadenceZone>(
    RawCadence_CadenceZone_descriptor(), name, value);
}
enum RawHeartrate_HeartrateZone {
  RawHeartrate_HeartrateZone_Repose = 0,
  RawHeartrate_HeartrateZone_Easy = 1,
  RawHeartrate_HeartrateZone_FatCombustion = 2,
  RawHeartrate_HeartrateZone_PossessionOxygenMotion = 3,
  RawHeartrate_HeartrateZone_NonOxygenatedMotion = 4,
  RawHeartrate_HeartrateZone_Overwork = 5
};
bool RawHeartrate_HeartrateZone_IsValid(int value);
const RawHeartrate_HeartrateZone RawHeartrate_HeartrateZone_HeartrateZone_MIN = RawHeartrate_HeartrateZone_Repose;
const RawHeartrate_HeartrateZone RawHeartrate_HeartrateZone_HeartrateZone_MAX = RawHeartrate_HeartrateZone_Overwork;
const int RawHeartrate_HeartrateZone_HeartrateZone_ARRAYSIZE = RawHeartrate_HeartrateZone_HeartrateZone_MAX + 1;

const ::google::protobuf::EnumDescriptor* RawHeartrate_HeartrateZone_descriptor();
inline const ::std::string& RawHeartrate_HeartrateZone_Name(RawHeartrate_HeartrateZone value) {
  return ::google::protobuf::internal::NameOfEnum(
    RawHeartrate_HeartrateZone_descriptor(), value);
}
inline bool RawHeartrate_HeartrateZone_Parse(
    const ::std::string& name, RawHeartrate_HeartrateZone* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RawHeartrate_HeartrateZone>(
    RawHeartrate_HeartrateZone_descriptor(), name, value);
}
// ===================================================================

class Extensions : public ::google::protobuf::Message {
 public:
  Extensions();
  virtual ~Extensions();

  Extensions(const Extensions& from);

  inline Extensions& operator=(const Extensions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Extensions& default_instance();

  void Swap(Extensions* other);

  // implements Message ----------------------------------------------

  Extensions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Extensions& from);
  void MergeFrom(const Extensions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline float level() const;
  inline void set_level(float value);

  // @@protoc_insertion_point(class_scope:eaglesakura_ace.Extensions)
 private:
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SensorProtocol_2eproto();
  friend void protobuf_AssignDesc_SensorProtocol_2eproto();
  friend void protobuf_ShutdownFile_SensorProtocol_2eproto();

  void InitAsDefaultInstance();
  static Extensions* default_instance_;
};
// -------------------------------------------------------------------

class RawCadence : public ::google::protobuf::Message {
 public:
  RawCadence();
  virtual ~RawCadence();

  RawCadence(const RawCadence& from);

  inline RawCadence& operator=(const RawCadence& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RawCadence& default_instance();

  void Swap(RawCadence* other);

  // implements Message ----------------------------------------------

  RawCadence* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RawCadence& from);
  void MergeFrom(const RawCadence& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RawCadence_CadenceZone CadenceZone;
  static const CadenceZone Easy = RawCadence_CadenceZone_Easy;
  static const CadenceZone Beginner = RawCadence_CadenceZone_Beginner;
  static const CadenceZone Ideal = RawCadence_CadenceZone_Ideal;
  static inline bool CadenceZone_IsValid(int value) {
    return RawCadence_CadenceZone_IsValid(value);
  }
  static const CadenceZone CadenceZone_MIN =
    RawCadence_CadenceZone_CadenceZone_MIN;
  static const CadenceZone CadenceZone_MAX =
    RawCadence_CadenceZone_CadenceZone_MAX;
  static const int CadenceZone_ARRAYSIZE =
    RawCadence_CadenceZone_CadenceZone_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CadenceZone_descriptor() {
    return RawCadence_CadenceZone_descriptor();
  }
  static inline const ::std::string& CadenceZone_Name(CadenceZone value) {
    return RawCadence_CadenceZone_Name(value);
  }
  static inline bool CadenceZone_Parse(const ::std::string& name,
      CadenceZone* value) {
    return RawCadence_CadenceZone_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 rpm = 100;
  inline bool has_rpm() const;
  inline void clear_rpm();
  static const int kRpmFieldNumber = 100;
  inline ::google::protobuf::int32 rpm() const;
  inline void set_rpm(::google::protobuf::int32 value);

  // required .eaglesakura_ace.RawCadence.CadenceZone cadenceZone = 101;
  inline bool has_cadencezone() const;
  inline void clear_cadencezone();
  static const int kCadenceZoneFieldNumber = 101;
  inline ::eaglesakura_ace::RawCadence_CadenceZone cadencezone() const;
  inline void set_cadencezone(::eaglesakura_ace::RawCadence_CadenceZone value);

  // @@protoc_insertion_point(class_scope:eaglesakura_ace.RawCadence)
 private:
  inline void set_has_rpm();
  inline void clear_has_rpm();
  inline void set_has_cadencezone();
  inline void clear_has_cadencezone();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 rpm_;
  int cadencezone_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SensorProtocol_2eproto();
  friend void protobuf_AssignDesc_SensorProtocol_2eproto();
  friend void protobuf_ShutdownFile_SensorProtocol_2eproto();

  void InitAsDefaultInstance();
  static RawCadence* default_instance_;
};
// -------------------------------------------------------------------

class RawHeartrate : public ::google::protobuf::Message {
 public:
  RawHeartrate();
  virtual ~RawHeartrate();

  RawHeartrate(const RawHeartrate& from);

  inline RawHeartrate& operator=(const RawHeartrate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RawHeartrate& default_instance();

  void Swap(RawHeartrate* other);

  // implements Message ----------------------------------------------

  RawHeartrate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RawHeartrate& from);
  void MergeFrom(const RawHeartrate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RawHeartrate_HeartrateZone HeartrateZone;
  static const HeartrateZone Repose = RawHeartrate_HeartrateZone_Repose;
  static const HeartrateZone Easy = RawHeartrate_HeartrateZone_Easy;
  static const HeartrateZone FatCombustion = RawHeartrate_HeartrateZone_FatCombustion;
  static const HeartrateZone PossessionOxygenMotion = RawHeartrate_HeartrateZone_PossessionOxygenMotion;
  static const HeartrateZone NonOxygenatedMotion = RawHeartrate_HeartrateZone_NonOxygenatedMotion;
  static const HeartrateZone Overwork = RawHeartrate_HeartrateZone_Overwork;
  static inline bool HeartrateZone_IsValid(int value) {
    return RawHeartrate_HeartrateZone_IsValid(value);
  }
  static const HeartrateZone HeartrateZone_MIN =
    RawHeartrate_HeartrateZone_HeartrateZone_MIN;
  static const HeartrateZone HeartrateZone_MAX =
    RawHeartrate_HeartrateZone_HeartrateZone_MAX;
  static const int HeartrateZone_ARRAYSIZE =
    RawHeartrate_HeartrateZone_HeartrateZone_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HeartrateZone_descriptor() {
    return RawHeartrate_HeartrateZone_descriptor();
  }
  static inline const ::std::string& HeartrateZone_Name(HeartrateZone value) {
    return RawHeartrate_HeartrateZone_Name(value);
  }
  static inline bool HeartrateZone_Parse(const ::std::string& name,
      HeartrateZone* value) {
    return RawHeartrate_HeartrateZone_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 bpm = 100;
  inline bool has_bpm() const;
  inline void clear_bpm();
  static const int kBpmFieldNumber = 100;
  inline ::google::protobuf::int32 bpm() const;
  inline void set_bpm(::google::protobuf::int32 value);

  // optional .eaglesakura_ace.RawHeartrate.HeartrateZone heartrateZone = 101;
  inline bool has_heartratezone() const;
  inline void clear_heartratezone();
  static const int kHeartrateZoneFieldNumber = 101;
  inline ::eaglesakura_ace::RawHeartrate_HeartrateZone heartratezone() const;
  inline void set_heartratezone(::eaglesakura_ace::RawHeartrate_HeartrateZone value);

  // @@protoc_insertion_point(class_scope:eaglesakura_ace.RawHeartrate)
 private:
  inline void set_has_bpm();
  inline void clear_has_bpm();
  inline void set_has_heartratezone();
  inline void clear_has_heartratezone();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 bpm_;
  int heartratezone_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SensorProtocol_2eproto();
  friend void protobuf_AssignDesc_SensorProtocol_2eproto();
  friend void protobuf_ShutdownFile_SensorProtocol_2eproto();

  void InitAsDefaultInstance();
  static RawHeartrate* default_instance_;
};
// ===================================================================


// ===================================================================

// Extensions

// optional float level = 1;
inline bool Extensions::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Extensions::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Extensions::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Extensions::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline float Extensions::level() const {
  return level_;
}
inline void Extensions::set_level(float value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// RawCadence

// required int32 rpm = 100;
inline bool RawCadence::has_rpm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawCadence::set_has_rpm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RawCadence::clear_has_rpm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RawCadence::clear_rpm() {
  rpm_ = 0;
  clear_has_rpm();
}
inline ::google::protobuf::int32 RawCadence::rpm() const {
  return rpm_;
}
inline void RawCadence::set_rpm(::google::protobuf::int32 value) {
  set_has_rpm();
  rpm_ = value;
}

// required .eaglesakura_ace.RawCadence.CadenceZone cadenceZone = 101;
inline bool RawCadence::has_cadencezone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RawCadence::set_has_cadencezone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RawCadence::clear_has_cadencezone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RawCadence::clear_cadencezone() {
  cadencezone_ = 0;
  clear_has_cadencezone();
}
inline ::eaglesakura_ace::RawCadence_CadenceZone RawCadence::cadencezone() const {
  return static_cast< ::eaglesakura_ace::RawCadence_CadenceZone >(cadencezone_);
}
inline void RawCadence::set_cadencezone(::eaglesakura_ace::RawCadence_CadenceZone value) {
  assert(::eaglesakura_ace::RawCadence_CadenceZone_IsValid(value));
  set_has_cadencezone();
  cadencezone_ = value;
}

// -------------------------------------------------------------------

// RawHeartrate

// required int32 bpm = 100;
inline bool RawHeartrate::has_bpm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawHeartrate::set_has_bpm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RawHeartrate::clear_has_bpm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RawHeartrate::clear_bpm() {
  bpm_ = 0;
  clear_has_bpm();
}
inline ::google::protobuf::int32 RawHeartrate::bpm() const {
  return bpm_;
}
inline void RawHeartrate::set_bpm(::google::protobuf::int32 value) {
  set_has_bpm();
  bpm_ = value;
}

// optional .eaglesakura_ace.RawHeartrate.HeartrateZone heartrateZone = 101;
inline bool RawHeartrate::has_heartratezone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RawHeartrate::set_has_heartratezone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RawHeartrate::clear_has_heartratezone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RawHeartrate::clear_heartratezone() {
  heartratezone_ = 0;
  clear_has_heartratezone();
}
inline ::eaglesakura_ace::RawHeartrate_HeartrateZone RawHeartrate::heartratezone() const {
  return static_cast< ::eaglesakura_ace::RawHeartrate_HeartrateZone >(heartratezone_);
}
inline void RawHeartrate::set_heartratezone(::eaglesakura_ace::RawHeartrate_HeartrateZone value) {
  assert(::eaglesakura_ace::RawHeartrate_HeartrateZone_IsValid(value));
  set_has_heartratezone();
  heartratezone_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace eaglesakura_ace

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eaglesakura_ace::RawCadence_CadenceZone>() {
  return ::eaglesakura_ace::RawCadence_CadenceZone_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eaglesakura_ace::RawHeartrate_HeartrateZone>() {
  return ::eaglesakura_ace::RawHeartrate_HeartrateZone_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SensorProtocol_2eproto__INCLUDED

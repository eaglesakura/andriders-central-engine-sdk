// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SensorProtocol.proto

#ifndef PROTOBUF_SensorProtocol_2eproto__INCLUDED
#define PROTOBUF_SensorProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "AcesConstants.pb.h"
// @@protoc_insertion_point(includes)

namespace eaglesakura_ace {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SensorProtocol_2eproto();
void protobuf_AssignDesc_SensorProtocol_2eproto();
void protobuf_ShutdownFile_SensorProtocol_2eproto();

class RawCadence;
class RawHeartrate;
class RawSpeed;
class SensorPayload;

enum RawCadence_CadenceZone {
  RawCadence_CadenceZone_Easy = 0,
  RawCadence_CadenceZone_Beginner = 1,
  RawCadence_CadenceZone_Ideal = 2
};
bool RawCadence_CadenceZone_IsValid(int value);
const RawCadence_CadenceZone RawCadence_CadenceZone_CadenceZone_MIN = RawCadence_CadenceZone_Easy;
const RawCadence_CadenceZone RawCadence_CadenceZone_CadenceZone_MAX = RawCadence_CadenceZone_Ideal;
const int RawCadence_CadenceZone_CadenceZone_ARRAYSIZE = RawCadence_CadenceZone_CadenceZone_MAX + 1;

const ::google::protobuf::EnumDescriptor* RawCadence_CadenceZone_descriptor();
inline const ::std::string& RawCadence_CadenceZone_Name(RawCadence_CadenceZone value) {
  return ::google::protobuf::internal::NameOfEnum(
    RawCadence_CadenceZone_descriptor(), value);
}
inline bool RawCadence_CadenceZone_Parse(
    const ::std::string& name, RawCadence_CadenceZone* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RawCadence_CadenceZone>(
    RawCadence_CadenceZone_descriptor(), name, value);
}
enum RawHeartrate_HeartrateZone {
  RawHeartrate_HeartrateZone_Repose = 0,
  RawHeartrate_HeartrateZone_Easy = 1,
  RawHeartrate_HeartrateZone_FatCombustion = 2,
  RawHeartrate_HeartrateZone_PossessionOxygenMotion = 3,
  RawHeartrate_HeartrateZone_NonOxygenatedMotion = 4,
  RawHeartrate_HeartrateZone_Overwork = 5
};
bool RawHeartrate_HeartrateZone_IsValid(int value);
const RawHeartrate_HeartrateZone RawHeartrate_HeartrateZone_HeartrateZone_MIN = RawHeartrate_HeartrateZone_Repose;
const RawHeartrate_HeartrateZone RawHeartrate_HeartrateZone_HeartrateZone_MAX = RawHeartrate_HeartrateZone_Overwork;
const int RawHeartrate_HeartrateZone_HeartrateZone_ARRAYSIZE = RawHeartrate_HeartrateZone_HeartrateZone_MAX + 1;

const ::google::protobuf::EnumDescriptor* RawHeartrate_HeartrateZone_descriptor();
inline const ::std::string& RawHeartrate_HeartrateZone_Name(RawHeartrate_HeartrateZone value) {
  return ::google::protobuf::internal::NameOfEnum(
    RawHeartrate_HeartrateZone_descriptor(), value);
}
inline bool RawHeartrate_HeartrateZone_Parse(
    const ::std::string& name, RawHeartrate_HeartrateZone* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RawHeartrate_HeartrateZone>(
    RawHeartrate_HeartrateZone_descriptor(), name, value);
}
enum RawSpeed_SpeedZone {
  RawSpeed_SpeedZone_Stop = 0,
  RawSpeed_SpeedZone_Slow = 1,
  RawSpeed_SpeedZone_Cruise = 2,
  RawSpeed_SpeedZone_Sprint = 3
};
bool RawSpeed_SpeedZone_IsValid(int value);
const RawSpeed_SpeedZone RawSpeed_SpeedZone_SpeedZone_MIN = RawSpeed_SpeedZone_Stop;
const RawSpeed_SpeedZone RawSpeed_SpeedZone_SpeedZone_MAX = RawSpeed_SpeedZone_Sprint;
const int RawSpeed_SpeedZone_SpeedZone_ARRAYSIZE = RawSpeed_SpeedZone_SpeedZone_MAX + 1;

const ::google::protobuf::EnumDescriptor* RawSpeed_SpeedZone_descriptor();
inline const ::std::string& RawSpeed_SpeedZone_Name(RawSpeed_SpeedZone value) {
  return ::google::protobuf::internal::NameOfEnum(
    RawSpeed_SpeedZone_descriptor(), value);
}
inline bool RawSpeed_SpeedZone_Parse(
    const ::std::string& name, RawSpeed_SpeedZone* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RawSpeed_SpeedZone>(
    RawSpeed_SpeedZone_descriptor(), name, value);
}
enum SensorType {
  HeartrateMonitor = 0,
  CadenceSensor = 1,
  SpeedSensor = 2
};
bool SensorType_IsValid(int value);
const SensorType SensorType_MIN = HeartrateMonitor;
const SensorType SensorType_MAX = SpeedSensor;
const int SensorType_ARRAYSIZE = SensorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SensorType_descriptor();
inline const ::std::string& SensorType_Name(SensorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SensorType_descriptor(), value);
}
inline bool SensorType_Parse(
    const ::std::string& name, SensorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorType>(
    SensorType_descriptor(), name, value);
}
// ===================================================================

class RawCadence : public ::google::protobuf::Message {
 public:
  RawCadence();
  virtual ~RawCadence();

  RawCadence(const RawCadence& from);

  inline RawCadence& operator=(const RawCadence& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RawCadence& default_instance();

  void Swap(RawCadence* other);

  // implements Message ----------------------------------------------

  RawCadence* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RawCadence& from);
  void MergeFrom(const RawCadence& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RawCadence_CadenceZone CadenceZone;
  static const CadenceZone Easy = RawCadence_CadenceZone_Easy;
  static const CadenceZone Beginner = RawCadence_CadenceZone_Beginner;
  static const CadenceZone Ideal = RawCadence_CadenceZone_Ideal;
  static inline bool CadenceZone_IsValid(int value) {
    return RawCadence_CadenceZone_IsValid(value);
  }
  static const CadenceZone CadenceZone_MIN =
    RawCadence_CadenceZone_CadenceZone_MIN;
  static const CadenceZone CadenceZone_MAX =
    RawCadence_CadenceZone_CadenceZone_MAX;
  static const int CadenceZone_ARRAYSIZE =
    RawCadence_CadenceZone_CadenceZone_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CadenceZone_descriptor() {
    return RawCadence_CadenceZone_descriptor();
  }
  static inline const ::std::string& CadenceZone_Name(CadenceZone value) {
    return RawCadence_CadenceZone_Name(value);
  }
  static inline bool CadenceZone_Parse(const ::std::string& name,
      CadenceZone* value) {
    return RawCadence_CadenceZone_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 rpm = 100;
  inline bool has_rpm() const;
  inline void clear_rpm();
  static const int kRpmFieldNumber = 100;
  inline ::google::protobuf::int32 rpm() const;
  inline void set_rpm(::google::protobuf::int32 value);

  // required .eaglesakura_ace.RawCadence.CadenceZone cadenceZone = 101;
  inline bool has_cadencezone() const;
  inline void clear_cadencezone();
  static const int kCadenceZoneFieldNumber = 101;
  inline ::eaglesakura_ace::RawCadence_CadenceZone cadencezone() const;
  inline void set_cadencezone(::eaglesakura_ace::RawCadence_CadenceZone value);

  // @@protoc_insertion_point(class_scope:eaglesakura_ace.RawCadence)
 private:
  inline void set_has_rpm();
  inline void clear_has_rpm();
  inline void set_has_cadencezone();
  inline void clear_has_cadencezone();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 rpm_;
  int cadencezone_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SensorProtocol_2eproto();
  friend void protobuf_AssignDesc_SensorProtocol_2eproto();
  friend void protobuf_ShutdownFile_SensorProtocol_2eproto();

  void InitAsDefaultInstance();
  static RawCadence* default_instance_;
};
// -------------------------------------------------------------------

class RawHeartrate : public ::google::protobuf::Message {
 public:
  RawHeartrate();
  virtual ~RawHeartrate();

  RawHeartrate(const RawHeartrate& from);

  inline RawHeartrate& operator=(const RawHeartrate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RawHeartrate& default_instance();

  void Swap(RawHeartrate* other);

  // implements Message ----------------------------------------------

  RawHeartrate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RawHeartrate& from);
  void MergeFrom(const RawHeartrate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RawHeartrate_HeartrateZone HeartrateZone;
  static const HeartrateZone Repose = RawHeartrate_HeartrateZone_Repose;
  static const HeartrateZone Easy = RawHeartrate_HeartrateZone_Easy;
  static const HeartrateZone FatCombustion = RawHeartrate_HeartrateZone_FatCombustion;
  static const HeartrateZone PossessionOxygenMotion = RawHeartrate_HeartrateZone_PossessionOxygenMotion;
  static const HeartrateZone NonOxygenatedMotion = RawHeartrate_HeartrateZone_NonOxygenatedMotion;
  static const HeartrateZone Overwork = RawHeartrate_HeartrateZone_Overwork;
  static inline bool HeartrateZone_IsValid(int value) {
    return RawHeartrate_HeartrateZone_IsValid(value);
  }
  static const HeartrateZone HeartrateZone_MIN =
    RawHeartrate_HeartrateZone_HeartrateZone_MIN;
  static const HeartrateZone HeartrateZone_MAX =
    RawHeartrate_HeartrateZone_HeartrateZone_MAX;
  static const int HeartrateZone_ARRAYSIZE =
    RawHeartrate_HeartrateZone_HeartrateZone_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HeartrateZone_descriptor() {
    return RawHeartrate_HeartrateZone_descriptor();
  }
  static inline const ::std::string& HeartrateZone_Name(HeartrateZone value) {
    return RawHeartrate_HeartrateZone_Name(value);
  }
  static inline bool HeartrateZone_Parse(const ::std::string& name,
      HeartrateZone* value) {
    return RawHeartrate_HeartrateZone_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 bpm = 100;
  inline bool has_bpm() const;
  inline void clear_bpm();
  static const int kBpmFieldNumber = 100;
  inline ::google::protobuf::int32 bpm() const;
  inline void set_bpm(::google::protobuf::int32 value);

  // required .eaglesakura_ace.RawHeartrate.HeartrateZone heartrateZone = 101;
  inline bool has_heartratezone() const;
  inline void clear_heartratezone();
  static const int kHeartrateZoneFieldNumber = 101;
  inline ::eaglesakura_ace::RawHeartrate_HeartrateZone heartratezone() const;
  inline void set_heartratezone(::eaglesakura_ace::RawHeartrate_HeartrateZone value);

  // @@protoc_insertion_point(class_scope:eaglesakura_ace.RawHeartrate)
 private:
  inline void set_has_bpm();
  inline void clear_has_bpm();
  inline void set_has_heartratezone();
  inline void clear_has_heartratezone();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 bpm_;
  int heartratezone_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SensorProtocol_2eproto();
  friend void protobuf_AssignDesc_SensorProtocol_2eproto();
  friend void protobuf_ShutdownFile_SensorProtocol_2eproto();

  void InitAsDefaultInstance();
  static RawHeartrate* default_instance_;
};
// -------------------------------------------------------------------

class RawSpeed : public ::google::protobuf::Message {
 public:
  RawSpeed();
  virtual ~RawSpeed();

  RawSpeed(const RawSpeed& from);

  inline RawSpeed& operator=(const RawSpeed& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RawSpeed& default_instance();

  void Swap(RawSpeed* other);

  // implements Message ----------------------------------------------

  RawSpeed* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RawSpeed& from);
  void MergeFrom(const RawSpeed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RawSpeed_SpeedZone SpeedZone;
  static const SpeedZone Stop = RawSpeed_SpeedZone_Stop;
  static const SpeedZone Slow = RawSpeed_SpeedZone_Slow;
  static const SpeedZone Cruise = RawSpeed_SpeedZone_Cruise;
  static const SpeedZone Sprint = RawSpeed_SpeedZone_Sprint;
  static inline bool SpeedZone_IsValid(int value) {
    return RawSpeed_SpeedZone_IsValid(value);
  }
  static const SpeedZone SpeedZone_MIN =
    RawSpeed_SpeedZone_SpeedZone_MIN;
  static const SpeedZone SpeedZone_MAX =
    RawSpeed_SpeedZone_SpeedZone_MAX;
  static const int SpeedZone_ARRAYSIZE =
    RawSpeed_SpeedZone_SpeedZone_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SpeedZone_descriptor() {
    return RawSpeed_SpeedZone_descriptor();
  }
  static inline const ::std::string& SpeedZone_Name(SpeedZone value) {
    return RawSpeed_SpeedZone_Name(value);
  }
  static inline bool SpeedZone_Parse(const ::std::string& name,
      SpeedZone* value) {
    return RawSpeed_SpeedZone_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required float speedKmPerHour = 1;
  inline bool has_speedkmperhour() const;
  inline void clear_speedkmperhour();
  static const int kSpeedKmPerHourFieldNumber = 1;
  inline float speedkmperhour() const;
  inline void set_speedkmperhour(float value);

  // optional float wheelRpm = 2;
  inline bool has_wheelrpm() const;
  inline void clear_wheelrpm();
  static const int kWheelRpmFieldNumber = 2;
  inline float wheelrpm() const;
  inline void set_wheelrpm(float value);

  // required float maxKmPerHour = 10;
  inline bool has_maxkmperhour() const;
  inline void clear_maxkmperhour();
  static const int kMaxKmPerHourFieldNumber = 10;
  inline float maxkmperhour() const;
  inline void set_maxkmperhour(float value);

  // required .eaglesakura_ace.RawSpeed.SpeedZone speedZone = 101;
  inline bool has_speedzone() const;
  inline void clear_speedzone();
  static const int kSpeedZoneFieldNumber = 101;
  inline ::eaglesakura_ace::RawSpeed_SpeedZone speedzone() const;
  inline void set_speedzone(::eaglesakura_ace::RawSpeed_SpeedZone value);

  // @@protoc_insertion_point(class_scope:eaglesakura_ace.RawSpeed)
 private:
  inline void set_has_speedkmperhour();
  inline void clear_has_speedkmperhour();
  inline void set_has_wheelrpm();
  inline void clear_has_wheelrpm();
  inline void set_has_maxkmperhour();
  inline void clear_has_maxkmperhour();
  inline void set_has_speedzone();
  inline void clear_has_speedzone();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float speedkmperhour_;
  float wheelrpm_;
  float maxkmperhour_;
  int speedzone_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_SensorProtocol_2eproto();
  friend void protobuf_AssignDesc_SensorProtocol_2eproto();
  friend void protobuf_ShutdownFile_SensorProtocol_2eproto();

  void InitAsDefaultInstance();
  static RawSpeed* default_instance_;
};
// -------------------------------------------------------------------

class SensorPayload : public ::google::protobuf::Message {
 public:
  SensorPayload();
  virtual ~SensorPayload();

  SensorPayload(const SensorPayload& from);

  inline SensorPayload& operator=(const SensorPayload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorPayload& default_instance();

  void Swap(SensorPayload* other);

  // implements Message ----------------------------------------------

  SensorPayload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorPayload& from);
  void MergeFrom(const SensorPayload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .eaglesakura_ace.SensorType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::eaglesakura_ace::SensorType type() const;
  inline void set_type(::eaglesakura_ace::SensorType value);

  // required bytes buffer = 10;
  inline bool has_buffer() const;
  inline void clear_buffer();
  static const int kBufferFieldNumber = 10;
  inline const ::std::string& buffer() const;
  inline void set_buffer(const ::std::string& value);
  inline void set_buffer(const char* value);
  inline void set_buffer(const void* value, size_t size);
  inline ::std::string* mutable_buffer();
  inline ::std::string* release_buffer();
  inline void set_allocated_buffer(::std::string* buffer);

  // @@protoc_insertion_point(class_scope:eaglesakura_ace.SensorPayload)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_buffer();
  inline void clear_has_buffer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* buffer_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SensorProtocol_2eproto();
  friend void protobuf_AssignDesc_SensorProtocol_2eproto();
  friend void protobuf_ShutdownFile_SensorProtocol_2eproto();

  void InitAsDefaultInstance();
  static SensorPayload* default_instance_;
};
// ===================================================================


// ===================================================================

// RawCadence

// required int32 rpm = 100;
inline bool RawCadence::has_rpm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawCadence::set_has_rpm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RawCadence::clear_has_rpm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RawCadence::clear_rpm() {
  rpm_ = 0;
  clear_has_rpm();
}
inline ::google::protobuf::int32 RawCadence::rpm() const {
  return rpm_;
}
inline void RawCadence::set_rpm(::google::protobuf::int32 value) {
  set_has_rpm();
  rpm_ = value;
}

// required .eaglesakura_ace.RawCadence.CadenceZone cadenceZone = 101;
inline bool RawCadence::has_cadencezone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RawCadence::set_has_cadencezone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RawCadence::clear_has_cadencezone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RawCadence::clear_cadencezone() {
  cadencezone_ = 0;
  clear_has_cadencezone();
}
inline ::eaglesakura_ace::RawCadence_CadenceZone RawCadence::cadencezone() const {
  return static_cast< ::eaglesakura_ace::RawCadence_CadenceZone >(cadencezone_);
}
inline void RawCadence::set_cadencezone(::eaglesakura_ace::RawCadence_CadenceZone value) {
  assert(::eaglesakura_ace::RawCadence_CadenceZone_IsValid(value));
  set_has_cadencezone();
  cadencezone_ = value;
}

// -------------------------------------------------------------------

// RawHeartrate

// required int32 bpm = 100;
inline bool RawHeartrate::has_bpm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawHeartrate::set_has_bpm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RawHeartrate::clear_has_bpm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RawHeartrate::clear_bpm() {
  bpm_ = 0;
  clear_has_bpm();
}
inline ::google::protobuf::int32 RawHeartrate::bpm() const {
  return bpm_;
}
inline void RawHeartrate::set_bpm(::google::protobuf::int32 value) {
  set_has_bpm();
  bpm_ = value;
}

// required .eaglesakura_ace.RawHeartrate.HeartrateZone heartrateZone = 101;
inline bool RawHeartrate::has_heartratezone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RawHeartrate::set_has_heartratezone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RawHeartrate::clear_has_heartratezone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RawHeartrate::clear_heartratezone() {
  heartratezone_ = 0;
  clear_has_heartratezone();
}
inline ::eaglesakura_ace::RawHeartrate_HeartrateZone RawHeartrate::heartratezone() const {
  return static_cast< ::eaglesakura_ace::RawHeartrate_HeartrateZone >(heartratezone_);
}
inline void RawHeartrate::set_heartratezone(::eaglesakura_ace::RawHeartrate_HeartrateZone value) {
  assert(::eaglesakura_ace::RawHeartrate_HeartrateZone_IsValid(value));
  set_has_heartratezone();
  heartratezone_ = value;
}

// -------------------------------------------------------------------

// RawSpeed

// required float speedKmPerHour = 1;
inline bool RawSpeed::has_speedkmperhour() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawSpeed::set_has_speedkmperhour() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RawSpeed::clear_has_speedkmperhour() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RawSpeed::clear_speedkmperhour() {
  speedkmperhour_ = 0;
  clear_has_speedkmperhour();
}
inline float RawSpeed::speedkmperhour() const {
  return speedkmperhour_;
}
inline void RawSpeed::set_speedkmperhour(float value) {
  set_has_speedkmperhour();
  speedkmperhour_ = value;
}

// optional float wheelRpm = 2;
inline bool RawSpeed::has_wheelrpm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RawSpeed::set_has_wheelrpm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RawSpeed::clear_has_wheelrpm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RawSpeed::clear_wheelrpm() {
  wheelrpm_ = 0;
  clear_has_wheelrpm();
}
inline float RawSpeed::wheelrpm() const {
  return wheelrpm_;
}
inline void RawSpeed::set_wheelrpm(float value) {
  set_has_wheelrpm();
  wheelrpm_ = value;
}

// required float maxKmPerHour = 10;
inline bool RawSpeed::has_maxkmperhour() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RawSpeed::set_has_maxkmperhour() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RawSpeed::clear_has_maxkmperhour() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RawSpeed::clear_maxkmperhour() {
  maxkmperhour_ = 0;
  clear_has_maxkmperhour();
}
inline float RawSpeed::maxkmperhour() const {
  return maxkmperhour_;
}
inline void RawSpeed::set_maxkmperhour(float value) {
  set_has_maxkmperhour();
  maxkmperhour_ = value;
}

// required .eaglesakura_ace.RawSpeed.SpeedZone speedZone = 101;
inline bool RawSpeed::has_speedzone() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RawSpeed::set_has_speedzone() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RawSpeed::clear_has_speedzone() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RawSpeed::clear_speedzone() {
  speedzone_ = 0;
  clear_has_speedzone();
}
inline ::eaglesakura_ace::RawSpeed_SpeedZone RawSpeed::speedzone() const {
  return static_cast< ::eaglesakura_ace::RawSpeed_SpeedZone >(speedzone_);
}
inline void RawSpeed::set_speedzone(::eaglesakura_ace::RawSpeed_SpeedZone value) {
  assert(::eaglesakura_ace::RawSpeed_SpeedZone_IsValid(value));
  set_has_speedzone();
  speedzone_ = value;
}

// -------------------------------------------------------------------

// SensorPayload

// required .eaglesakura_ace.SensorType type = 2;
inline bool SensorPayload::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorPayload::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorPayload::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorPayload::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::eaglesakura_ace::SensorType SensorPayload::type() const {
  return static_cast< ::eaglesakura_ace::SensorType >(type_);
}
inline void SensorPayload::set_type(::eaglesakura_ace::SensorType value) {
  assert(::eaglesakura_ace::SensorType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required bytes buffer = 10;
inline bool SensorPayload::has_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorPayload::set_has_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorPayload::clear_has_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorPayload::clear_buffer() {
  if (buffer_ != &::google::protobuf::internal::kEmptyString) {
    buffer_->clear();
  }
  clear_has_buffer();
}
inline const ::std::string& SensorPayload::buffer() const {
  return *buffer_;
}
inline void SensorPayload::set_buffer(const ::std::string& value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void SensorPayload::set_buffer(const char* value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void SensorPayload::set_buffer(const void* value, size_t size) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SensorPayload::mutable_buffer() {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  return buffer_;
}
inline ::std::string* SensorPayload::release_buffer() {
  clear_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buffer_;
    buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SensorPayload::set_allocated_buffer(::std::string* buffer) {
  if (buffer_ != &::google::protobuf::internal::kEmptyString) {
    delete buffer_;
  }
  if (buffer) {
    set_has_buffer();
    buffer_ = buffer;
  } else {
    clear_has_buffer();
    buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace eaglesakura_ace

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eaglesakura_ace::RawCadence_CadenceZone>() {
  return ::eaglesakura_ace::RawCadence_CadenceZone_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eaglesakura_ace::RawHeartrate_HeartrateZone>() {
  return ::eaglesakura_ace::RawHeartrate_HeartrateZone_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eaglesakura_ace::RawSpeed_SpeedZone>() {
  return ::eaglesakura_ace::RawSpeed_SpeedZone_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eaglesakura_ace::SensorType>() {
  return ::eaglesakura_ace::SensorType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SensorProtocol_2eproto__INCLUDED
